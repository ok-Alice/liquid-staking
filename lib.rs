#![cfg_attr(not(feature = "std"), no_std)]

#[ink::contract]
mod delegator {
    use ink::prelude::vec::Vec;

    use issuer::IssuerRef;

    /// Delegates calls to `issuer` contract to stake and unstake.
    ///
    /// # Note
    ///
    /// In order to instantiate the `delegator` smart contract we first
    /// have to manually put the code of the `issuer` and `staker` smart
    /// contracts, receive their code hashes from
    /// the signalled events and put their code hash into our
    /// `delegator` smart contract.
    ///
    /// The `IssuerRef` is a smart contract
    /// reference type that has been automatically generated by ink!.
    #[ink(storage)]
    pub struct Delegator {
        /// The `issuer` smart contract.
        issuer: IssuerRef,
    }

    impl Delegator {
        /// Instantiate a `delegator` contract with the given sub-contract codes.
        #[ink(constructor)]
        pub fn new(version: u32, issuer_code_hash: Hash, staker_code_hash: Hash) -> Self {
            // let total_balance = Self::env().balance();
            let salt = version.to_le_bytes();
            let issuer = IssuerRef::new(staker_code_hash)
                .endowment(0)
                .code_hash(issuer_code_hash)
                .salt_bytes(salt)
                .instantiate();
            Self { issuer }
        }

        /// Stake
        #[ink(message)]
        pub fn stake(&self, by: i32) {
            self.issuer.stake(by)
        }

        /// Unstake
        #[ink(message)]
        pub fn unstake(&self) {
            self.issuer.unstake();
        }

        /// List callers from subsequent cross-contract calls
        #[ink(message)]
        pub fn callers(&self) -> Vec<AccountId> {
            let mut callers = self.issuer.callers();
            callers.push(self.env().caller());
            callers
        }
    }
}
